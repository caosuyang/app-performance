# 性能优化-容错机制

## 常见容错机制使用场景

1. 对后台返回到前端数据容错，比如，字典、数组（野指针、NSNull）
2. 如果一开始没有对后台返回到前端数据容错，需要事后处理，拦截潜在的崩溃，比如：category给类添加⽅法替换掉原本存在潜在崩溃的⽅法、利⽤runtime⽅法交换技术，将系统⽅法替换成类添加的新⽅法、利⽤异常的捕获来防⽌程序的崩溃，并且进⾏相应的处理

注意：1是数据容错处理，一般常说的项目容错机制是指这个，而容错的数据，有待验证。
注意：2是未容错而进行的事后处理，是一种拦截潜在崩溃的手段，严格意义上不算做容错处理。

## 项目如何容错处理

1. 对后台返回到前端数据容错，比如，字典、数组（野指针、NSNull）
2. 在后台返回值为Null为空时，我们代码没有判断时，程序就会崩溃，对null做容错处理。
3. 比如，后台返回字典或数组数据，后台返回 null，前端接收的是NSNull类型。
4. 例如从服务器取回来的数据，如果其中有一个NSNUll对象的字典或者数组，那么就会出错。

注意：数据造成crash情况和原理，有待验证。

## 如果项目开始容错处理没做，如何防止拦截潜在的崩溃？

1. 防止拦截潜在的崩溃，意味着运行时、事后处理。
2. category给类添加⽅法⽤来替换掉原本存在潜在崩溃的⽅法。
3. 利⽤runtime⽅法交换技术，将系统⽅法替换成类添加的新⽅法。
4. 利⽤异常的捕获来防⽌程序的崩溃，并且进⾏相应的处理

注意：不要过分相信服务器返回的数据会永远的正确，在对数据处理上，要进⾏容错处理，进⾏相应判断之后再处理数据，这是⼀个良好的编程习惯。

## 字典怎么去容错

1. 网络请求时去处理：如果使用是AFNetwork做网络请求的话，可以用removesKeysWithNullValues，会自动去除空值（在序列化时自动做了处理）
2. 请求后拿到字典数据时：字符串匹配。在获取到服务器返回的Json时(返回结果是string对象)通过stringByReplacingOccurrencesOfString方法，替换"null"为"空字符"，然后解析。（容错机制）
3. 事后拦截：使用 runtime，在运行时操作，把空值置为nil，而nil是安全的，可以向nil对象发送任何message而不会奔溃。（事后处理）

## 后台返回 null，前端接收的是什么类型

1. NSNull 对象。
2. NSNull和nil的区别在于，nil是一个空对象，已经完全从内存中消失了，而如果我们想表达“我们需要有这样一个容器，但这个容器里什么也没有”的观念时，我们就用到NSNull，我称它为“值为空的对象”。
3. 如果你查阅开发文档你会发现NSNull这个类是继承NSObject，并且只有一个“+ (NSNull *) null；”类方法。这就说明NSNull对象拥有一个有效的内存地址，所以在程序中对它的任何引用都是不会导致程序崩溃的。
4. 这里其实不是完全的，例如从服务器取回来的数据，如果其中有一个NSNUll对象的字典或者数组，那么就会出错。

注意：4这种情况为什么会出错crash，原因有待验证。

## nil、Nil、NSULL、NULL区别

1. Nil：nil和Nil在使用上是没有严格限定的，也就是说凡是使用nil的地方都可以用Nil来代替，反之亦然。只不过从编程人员的规约中我们约定俗成地将nil表示一个空对象，Nil表示一个空类
2. NULL：Object-C来源于C、支持于C,当然也有别于C。而NULL就是典型C语言的语法，它表示一个空指针
3. NSULL：NSNull和nil的区别在于，nil是一个空对象，已经完全从内存中消失了，而如果我们想表达“我们需要有这样一个容器，但这个容器里什么也没有”的观念时，我们就用到NSNull，我称它为“值为空的对象”
4. nil：给对象赋值时一般会使用object = nil，表示我想把这个对象释放掉，或者经过多次release，于是对象引用计数器为0了，系统将这块内存释放掉，这个时候这个对象为nil，我称它为“空对象”。

## crash率减低前后情况

1. 崩溃率（也就是一段时间内崩溃次数与启动次数之比）作为优先级最高的技术指标，比如千分位是生死线，万分位是达标线等，去衡量一个 App 的高可用性
2. 根据bugly崩溃在线数据分析可知，项目崩溃率优化前 0.5% 以上，优化后稳定在 0.2% 以内，一定时间始终保持在千分位生死线以内。