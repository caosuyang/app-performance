# 性能优化-Runloop监控卡顿

## 导致卡顿问题原因

1. 复杂 UI 、图文混排的绘制量过大
2. 在主线程上做网络同步请求
3. 在主线程做大量的 IO 操作
4. 运算量过大，CPU 持续高占用
5. 死锁和主子线程抢锁

## 判断卡顿阶段

1. 如果 RunLoop 的线程，进入睡眠前方法的执行时间过长而导致无法进入睡眠，或者线程唤醒后接收消息时间过长而无法进入下一步的话，就可以认为是线程受阻了。如果这个线程是主线程的话，表现出来的就是出现了卡顿。
2. 所以，如果我们要利用 RunLoop 原理来监控卡顿的话，就是要关注这两个阶段。RunLoop 在进入睡眠之前和唤醒后的两个 loop 状态定义的值，分别是 kCFRunLoopBeforeSources 和 kCFRunLoopAfterWaiting ，也就是要触发 Source0 回调和接收 mach_port 消息两个状态。

## 如何检查卡顿

1. 首先，创建一个 observerCtx 观察者
2. 将创建好的观察者添加到主线程 runloop 的 common 模式下观察
3. 然后，创建一个持续的子线程用于监控主线程的 runloop 状态 (do while)
4. 创建一个 dispatch_semphore_wait 信号量，超时时间阈值设置为 3 s，小于 watchdog 限制时间即可
5. 如果下面判断信号量大于0，那么表示信号量等待时间超过3ms，放开了锁
6. 如果 observer 正好处于 BeforeSources 或 AfterWaiting 状态
7. 即可发现进入睡眠前的 kCFRunLoopBeforeSources 状态，或者唤醒后的状态 kCFRunLoopAfterWaiting，在设置的时间阈值内一直没有变化，即可判定为卡顿
8. 接下来，我们就可以 dump 出堆栈的信息，从而进一步分析出具体是哪个方法的执行时间过长

## WatchDog 机制

1. WatchDog 在不同状态下设置的不同时间，如下所示：
2. 启动（Launch）：20s；
3. 恢复（Resume）：10s；
4. 挂起（Suspend）：10s；
5. 退出（Quit）：6s；
6. 后台（Background）：3min（在 iOS 7 之前，每次申请 10min； 之后改为每次申请 3min，可连续申请，最多申请到 10min）。
7. 通过 WatchDog 设置的时间，认为可以把启动的阈值设置为 10 秒，其他状态则都默认设置为 3 秒。

注意：WatchDog 机制使用场景有待验证。

## 如何获取卡顿的方法堆栈信息

1. 获取堆栈信息的一种方法是直接调用系统函数。
2. 另一种方法是，直接用 PLCrashReporter这个开源的第三方库来获取堆栈信息。

### 直接调用系统函数

1. 这种方法的优点在于，性能消耗小。但是，它只能够获取简单的信息，也没有办法配合 dSYM 来获取具体是哪行代码出了问题，而且能够获取的信息类型也有限。这种方法，因为性能比较好，所以适用于观察大盘统计卡顿情况，而不是想要找到卡顿原因的场景。
2. 直接调用系统函数方法的主要思路是：用 signal 进行错误信息的获取。

### PLCrashReporter获取堆栈信息

1. 这种方法的特点是，能够定位到问题代码的具体位置，而且性能消耗也不大。所以，也是推荐的获取堆栈信息的方法。
2. 具体如何使用 PLCrashReporter 来获取堆栈信息，获取数据->转换成 PLCrashReport 对象->进行字符串格式化处理->将字符串上传服务器。